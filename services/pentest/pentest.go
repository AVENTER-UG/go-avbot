package pentest

import (
	"bytes"
	"encoding/base64"
	"fmt"
	"strings"

	"../../types"
	log "github.com/Sirupsen/logrus"
	"github.com/matrix-org/gomatrix"
)

// ServiceType of the Invoice service
const ServiceType = "pentest"

// Service represents the Invoice service. It has no Config fields.
type Service struct {
	types.DefaultService
	// IP of the OpenVAS Manager
	OpenVASIP string
	// Port  of the OpenVAS Manager
	OpenVASPort string
	// Username of the OpenVAS Manager
	OpenVASUsername string
	// Password of the OpenVAS Manager
	OpenVASPassword string
	// The Users who are allowed to use the invoice service
	AllowedUsers string
}

// Commands supported:
//    !invoice help
func (s *Service) Commands(cli *gomatrix.Client) []types.Command {
	return []types.Command{
		types.Command{
			Path: []string{"pentest", "help"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				var message string
				message = fmt.Sprintf("##### Help \n")
				message = message + fmt.Sprintf("```\n")
				message = message + fmt.Sprintf("scan\n======\n\t name : short scan description \n\t target : target ip or name \n\t scan config id : the scan config id u can find with !pentest show scanid \n\n")
				message = message + fmt.Sprintf("show scanid\n======\n\t Give out a list of all scan config ids\n\n")
				message = message + fmt.Sprintf("show reportformat\n======\n\t Give out a list of all report format ids\n\n")
				message = message + fmt.Sprintf("show report\n======\n\t scanID : Give out the current scan status \n\n")
				message = message + fmt.Sprintf("get report\n======\n\t scanID : Get the Report as PDF \n\t formatId : the format id you can find out with !pentest show reportformat \n\n")
				message = message + fmt.Sprintf("```\n")

				return &gomatrix.HTMLMessage{message, "m.text", "org.matrix.custom.html", markdownRender(message)}, nil
			},
		},
		types.Command{
			Path: []string{"pentest", "scan"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				if strings.Contains(s.AllowedUsers, userID) {
					return s.cmdScanTarget(roomID, userID, args)
				} else {
					return &gomatrix.TextMessage{"m.notice", "U are not allowed to use this function"}, nil
				}
			},
		},
		types.Command{
			Path: []string{"pentest", "show", "scanid"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				if strings.Contains(s.AllowedUsers, userID) {
					return s.cmdGetScanConfigIDs(roomID, userID, args)
				} else {
					return &gomatrix.TextMessage{"m.notice", "U are not allowed to use this function"}, nil
				}
			},
		},
		types.Command{
			Path: []string{"pentest", "show", "reportformat"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				if strings.Contains(s.AllowedUsers, userID) {
					return s.cmdGetReportFormatIDs(roomID, userID, args)
				} else {
					return &gomatrix.TextMessage{"m.notice", "U are not allowed to use this function"}, nil
				}
			},
		},
		types.Command{
			Path: []string{"pentest", "show", "report"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				if strings.Contains(s.AllowedUsers, userID) {
					return s.cmdGetReport(roomID, userID, args)
				} else {
					return &gomatrix.TextMessage{"m.notice", "U are not allowed to use this function"}, nil
				}
			},
		},
		types.Command{
			Path: []string{"pentest", "get", "report"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				if strings.Contains(s.AllowedUsers, userID) {
					return s.cmdDownloadReport(roomID, userID, cli, args)
				} else {
					return &gomatrix.TextMessage{"m.notice", "U are not allowed to use this function"}, nil
				}
			},
		},
	}
}

func init() {
	types.RegisterService(func(serviceID, serviceUserID, webhookEndpointURL string) types.Service {
		return &Service{
			DefaultService: types.NewDefaultService(serviceID, serviceUserID, ServiceType),
		}
	})
}

// scan a server
func (s *Service) cmdScanTarget(roomID, userID string, args []string) (interface{}, error) {
	if len(args) < 3 {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf(`Missing parameters. Have a look with !pentest help`)}, nil
	}

	var name = args[0]
	var target = args[1]
	var scanConfigID = args[2]

	// Authentication against openVAS
	if s.omgAuthentication(userID) != "200" {
		return &gomatrix.TextMessage{"m.notice", "OpenVAS think u are not trustfull enough :-)"}, nil
	}

	// let us create a target
	targetId, status := s.createTarget(name, target)
	if status == "400" {
		// TODO: If its already exist, delete it
		return &gomatrix.TextMessage{"m.notice", "Target already exist"}, nil
	}
	if status != "201" {
		return &gomatrix.TextMessage{"m.notice", "Could not create target"}, nil
	}

	taskId, status := s.createTask(name, scanConfigID, targetId)
	if status == "400" {
		// TODO: If its already exist, delete it
		return &gomatrix.TextMessage{"m.notice", "Task already exist"}, nil
	}
	if status != "201" {
		return &gomatrix.TextMessage{"m.notice", "Could not create task"}, nil
	}

	reportId, status, statusText := s.startTask(taskId)
	if status != "202" {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf("Could not run the task with id: %s", taskId)}, nil
	}

	res, status := s.getReport(reportId)
	if status != "200" {
		return &gomatrix.TextMessage{"m.notice", "Could not find the report"}, nil
	}

	var message string
	message = message + fmt.Sprintf("```\n")
	message = message + fmt.Sprintf("SCAN STATUS:   %s \n", printValueStr(statusText, 40))
	message = message + fmt.Sprintf("REPORT STATUS: %s \n", printValueStr(res, 40))
	message = message + fmt.Sprintf("REPORT ID:     %s \n", printValueStr(reportId, 50))
	message = message + fmt.Sprintf("```\n")

	return &gomatrix.HTMLMessage{message, "m.text", "org.matrix.custom.html", markdownRender(message)}, nil

}

// this function will give out a list of all in OpenVAS configured Scanner Configs
func (s *Service) cmdGetScanConfigIDs(roomID, userID string, args []string) (interface{}, error) {
	// Authentication against openVAS
	if s.omgAuthentication(userID) != "200" {
		return &gomatrix.TextMessage{"m.notice", "OpenVAS think u are not trustfull enough :-)"}, nil
	}

	res, status := s.getScanConfigIDs()
	if status != "200" {
		return &gomatrix.TextMessage{"m.notice", "Could not find scan config id's"}, nil
	}

	var message string
	message = fmt.Sprintf("##### Scan Configs \n")
	message = message + fmt.Sprintf("```\n")
	message = message + fmt.Sprintf("| %s ", printValueStr("ID", 40))
	message = message + fmt.Sprintf("| %s ", printValueStr("NAME", 20))
	message = message + fmt.Sprintf("| %s\n", printValueStr("COMMENT", 50))

	for i := 0; i < len(res.Get_configs_response.Config); i++ {
		message = message + fmt.Sprintf("| %s ", printValueStr(res.Get_configs_response.Config[i].Id, 40))
		message = message + fmt.Sprintf("| %s ", printValueStr(res.Get_configs_response.Config[i].Name[0], 20))
		message = message + fmt.Sprintf("| %s\n", printValueStr(res.Get_configs_response.Config[i].Comment[0], 50))
	}
	message = message + fmt.Sprintf("```\n")
	return &gomatrix.HTMLMessage{message, "m.text", "org.matrix.custom.html", markdownRender(message)}, nil
}

// this function will give out a list of all in OpenVAS configured report formats
func (s *Service) cmdGetReportFormatIDs(roomID, userID string, args []string) (interface{}, error) {
	// Authentication against openVAS
	if s.omgAuthentication(userID) != "200" {
		return &gomatrix.TextMessage{"m.notice", "OpenVAS think u are not trustfull enough :-)"}, nil
	}

	res, status := s.getReportFormatIDs()
	if status != "200" {
		return &gomatrix.TextMessage{"m.notice", "Could not find scan config id's"}, nil
	}

	var message string
	message = fmt.Sprintf("##### Report Formats \n")
	message = message + fmt.Sprintf("```\n")
	message = message + fmt.Sprintf("| %s ", printValueStr("ID", 40))
	message = message + fmt.Sprintf("| %s ", printValueStr("NAME", 20))

	for i := 0; i < len(res.GetReportFormatsResponse.ReportFormat); i++ {
		message = message + fmt.Sprintf("| %s ", printValueStr(res.GetReportFormatsResponse.ReportFormat[i].Id, 40))
		message = message + fmt.Sprintf("| %s \n", printValueStr(res.GetReportFormatsResponse.ReportFormat[i].Name, 20))
	}

	message = message + fmt.Sprintf("```\n")

	return &gomatrix.HTMLMessage{message, "m.text", "org.matrix.custom.html", markdownRender(message)}, nil
}

// get the current status of a report
func (s *Service) cmdGetReport(roomID, userID string, args []string) (interface{}, error) {
	if len(args) < 1 {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf(`Missing parameters. Have a look with !pentest help`)}, nil
	}

	var reportID = args[0]

	// Authentication against openVAS
	if s.omgAuthentication(userID) != "200" {
		return &gomatrix.TextMessage{"m.notice", "OpenVAS think u are not trustfull enough :-)"}, nil
	}

	res, status := s.getReport(reportID)
	if status != "200" {
		return &gomatrix.TextMessage{"m.notice", "Could not find the report"}, nil
	}

	var message string
	message = message + fmt.Sprintf("```\n")
	message = message + fmt.Sprintf("REPORT STATUS: %s \n", printValueStr(res, 40))
	message = message + fmt.Sprintf("```\n")

	return &gomatrix.HTMLMessage{message, "m.text", "org.matrix.custom.html", markdownRender(message)}, nil
}

func (s *Service) cmdDownloadReport(roomID, userID string, cli *gomatrix.Client, args []string) (interface{}, error) {
	if len(args) < 2 {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf(`Missing parameters. Have a look with !pentest help`)}, nil
	}

	var reportId = args[0]
	var formatId = args[1]

	// Authentication against openVAS
	if s.omgAuthentication(userID) != "200" {
		return &gomatrix.TextMessage{"m.notice", "OpenVAS think u are not trustfull enough :-)"}, nil
	}

	data, contentType, extension, status := s.getReportInFormat(reportId, formatId)
	if status != "200" {
		return &gomatrix.TextMessage{"m.notice", "Could not find the report"}, nil
	}

	dataDecode, err := base64.StdEncoding.DecodeString(data)
	if err != nil {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf("Could not decode data: %s", err)}, nil
	}

	rmu, err := cli.UploadToContentRepo(bytes.NewReader(dataDecode), contentType, int64(len(dataDecode)))
	if err != nil {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf("Could not upload the report: %s", err)}, nil
	}
	log.Info(rmu.ContentURI)

	return &gomatrix.FileMessage{
		Body:    fmt.Sprintf("%s.%s", reportId, extension),
		MsgType: "m.file",
		URL:     rmu.ContentURI,
		Info: gomatrix.FileInfo{
			MimeType: contentType,
			Size:     int64(len(data)),
		},
	}, nil

}
