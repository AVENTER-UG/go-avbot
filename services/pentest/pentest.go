// Package invoice implements a Service which create invoices
package pentest

import (
	"crypto/tls"
	"encoding/xml"
	"fmt"
	"strings"

	"../../types"
	log "github.com/Sirupsen/logrus"
	"github.com/matrix-org/gomatrix"
	"github.com/russross/blackfriday"
)

// ServiceType of the Invoice service
const ServiceType = "pentest"

// Service represents the Invoice service. It has no Config fields.
type Service struct {
	types.DefaultService
	// IP of the OpenVAS Manager
	OpenVASIP string
	// Port  of the OpenVAS Manager
	OpenVASPort string
	// The Users who are allowed to use the invoice service
	AllowedUsers string
}

// Commands supported:
//    !invoice help
func (s *Service) Commands(cli *gomatrix.Client) []types.Command {
	return []types.Command{
		types.Command{
			Path: []string{"pentest", "help"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				var message string
				message = fmt.Sprintf("##### Help \n")
				message = message + fmt.Sprintf("```\n")
				message = message + fmt.Sprintf("```\n")

				return &gomatrix.HTMLMessage{message, "m.text", "org.matrix.custom.html", markdownRender(message)}, nil
			},
		},
		types.Command{
			Path: []string{"pentest", "test"},
			Command: func(roomID, userID string, args []string) (interface{}, error) {
				if strings.Contains(s.AllowedUsers, userID) {
					return s.omgAuthentication(userID)
				} else {
					return &gomatrix.TextMessage{"m.notice", "U are not allowed to use this function"}, nil
				}
			},
		},
	}
}

func init() {
	types.RegisterService(func(serviceID, serviceUserID, webhookEndpointURL string) types.Service {
		return &Service{
			DefaultService: types.NewDefaultService(serviceID, serviceUserID, ServiceType),
		}
	})
}

// Authenticate against OpenVAS
func (s *Service) omgAuthentication(userID string) (interface{}, error) {
	xmlMsg := "<authenticate><credentials><username>admin</username><password>admin</password></credentials></authenticate>"
	message := s.sendSocket(xmlMsg)

	var res AuthenticateResponse
	err := xml.Unmarshal([]byte(message), &res)
	if err != nil {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf("There is something wrong: %s", err)}, nil
	}

	if res.Status != "200" {
		return &gomatrix.TextMessage{"m.notice", fmt.Sprintf("Thats looks not good: %s %s", res.Status, res.StatusText)}, nil
	}
	return &gomatrix.TextMessage{"m.notice", message}, nil
}

// Function to send xml command to the openvas ssl socket
func (s *Service) sendSocket(message string) string {
	stopCharacter := "\r\n\r\n"
	addr := strings.Join([]string{s.OpenVASIP, s.OpenVASPort}, ":")
	conn, err := tls.Dial("tcp", addr, &tls.Config{InsecureSkipVerify: true})

	defer conn.Close()

	if err != nil {
		log.Info("Service: Pentest:", err)
	}

	conn.Write([]byte(message))
	conn.Write([]byte(stopCharacter))

	buff := make([]byte, 1024)
	n, _ := conn.Read(buff)
	return fmt.Sprintf("%s", buff[:n])
}

func markdownRender(content string) string {
	htmlFlags := 0
	htmlFlags |= blackfriday.HTML_USE_SMARTYPANTS
	htmlFlags |= blackfriday.HTML_SMARTYPANTS_FRACTIONS

	renderer := blackfriday.HtmlRenderer(htmlFlags, "", "")

	extensions := 0
	extensions |= blackfriday.EXTENSION_NO_INTRA_EMPHASIS
	extensions |= blackfriday.EXTENSION_TABLES
	extensions |= blackfriday.EXTENSION_FENCED_CODE
	extensions |= blackfriday.EXTENSION_AUTOLINK
	extensions |= blackfriday.EXTENSION_STRIKETHROUGH
	extensions |= blackfriday.EXTENSION_SPACE_HEADERS

	return string(blackfriday.Markdown([]byte(content), renderer, extensions))
}
