// Package pentest implements a Service to penetrate a server and crate reports of the result
package pentest

import (
	"crypto/tls"
	"encoding/xml"
	"fmt"
	"strings"

	"github.com/russross/blackfriday"
	log "github.com/sirupsen/logrus"
)

// start a task in OpenVAS
func (s *Service) startTask(taskID string) (string, string, string) {
	var xmlMsg string
	xmlMsg = xmlMsg + fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	xmlMsg = xmlMsg + fmt.Sprintf("<start_task task_id=\"%s\"/>", taskID)
	message := s.sendSocket(xmlMsg)

	var res StartTaskResponse

	err := xml.Unmarshal([]byte("<StartTaskResponse>"+message+"</StartTaskResponse>"), &res)
	if err != nil {
		return "", "", "400"
	}

	return res.StartTask.ReportID, res.StartTask.Status, res.StartTask.StatusText
}

// create a task in OpenVAS
func (s *Service) createTask(name, scanConfigID, targetID string) (string, string) {
	var xmlMsg string
	xmlMsg = xmlMsg + fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	xmlMsg = xmlMsg + fmt.Sprintf("<create_task><name>%s</name><config id=\"%s\"/><target id=\"%s\"/></create_task>", name, scanConfigID, targetID)
	message := s.sendSocket(xmlMsg)

	var res CreateTaskResponse

	err := xml.Unmarshal([]byte("<CreateTaskResponse>"+message+"</CreateTaskResponse>"), &res)
	if err != nil {
		return "", "400"
	}

	return res.CreateTask.ID, res.CreateTask.Status
}

// get out a report
func (s *Service) getReportInFormat(reportID, formatID string) (string, string, string, string) {
	var xmlMsg string
	xmlMsg = xmlMsg + fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	xmlMsg = xmlMsg + fmt.Sprintf("<get_reports report_id=\"%s\" format_id=\"%s\"/>", reportID, formatID)
	message := s.sendSocket(xmlMsg)

	var res GetReportsResponseInFormat

	err := xml.Unmarshal([]byte("<GetReportsResponse>"+message+"</GetReportsResponse>"), &res)
	if err != nil {
		return "", "", "", "400"
	}

	return res.GetReportsResponse.Report.Data, res.GetReportsResponse.Report.ContentType, res.GetReportsResponse.Report.Extension, res.GetReportsResponse.Status
}

// get out a report
func (s *Service) getReport(reportID string) (string, string) {
	var xmlMsg string
	xmlMsg = xmlMsg + fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	xmlMsg = xmlMsg + fmt.Sprintf("<get_reports report_id=\"%s\"/>", reportID)
	message := s.sendSocket(xmlMsg)

	var res GetReportsResponse

	err := xml.Unmarshal([]byte("<GetReportsResponse>"+message+"</GetReportsResponse>"), &res)
	if err != nil {
		return "", "400"
	}
	return res.GetReportsResponse.Report.Report.ScanRunStatus, res.GetReportsResponse.Status
}

// get out all scan config id's
func (s *Service) getReportFormatIDs() (GetReportFormatsResponse, string) {
	var xmlMsg string
	xmlMsg = xmlMsg + fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	xmlMsg = xmlMsg + fmt.Sprintf("<get_report_formats/>")
	message := s.sendSocket(xmlMsg)
	var res GetReportFormatsResponse

	err := xml.Unmarshal([]byte("<GetReportFormatsResponse>"+message+"</GetReportFormatsResponse>"), &res)
	if err != nil {
		return res, "400"
	}

	return res, res.GetReportFormatsResponse.Status
}

// get out all scan config id's
func (s *Service) getScanConfigIDs() (GetConfigsResponse, string) {
	var xmlMsg string
	xmlMsg = xmlMsg + fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	xmlMsg = xmlMsg + fmt.Sprintf("<get_configs/>")
	message := s.sendSocket(xmlMsg)

	var res GetConfigsResponse

	err := xml.Unmarshal([]byte("<GetConfigsResponse>"+message+"</GetConfigsResponse>"), &res)
	if err != nil {
		return res, "400"
	}

	return res, res.GetConfigsResponse.Status
}

// create a scan target in OpenVAS
func (s *Service) createTarget(name, target string) (string, string) {
	var xmlMsg string
	xmlMsg = xmlMsg + fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	xmlMsg = xmlMsg + fmt.Sprintf("<create_target><name>%s</name><hosts>%s</hosts></create_target>", name, target)
	message := s.sendSocket(xmlMsg)

	var res CreateTargetResponse

	err := xml.Unmarshal([]byte("<CreateTargetResponse>"+message+"</CreateTargetResponse>"), &res)
	if err != nil {
		return "", "400"
	}
	return res.CreateTarget.ID, res.CreateTarget.Status
}

// Authenticate against OpenVAS
func (s *Service) omgAuthentication(userID string) string {
	xmlMsg := fmt.Sprintf("<authenticate><credentials><username>%s</username><password>%s</password></credentials></authenticate>", s.OpenVASUsername, s.OpenVASPassword)
	message := s.sendSocket(xmlMsg)

	var res AuthenticateResponse
	err := xml.Unmarshal([]byte(message), &res)
	if err != nil {
		return "400"
	}
	return res.Status
}

// Function to send xml command to the openvas ssl socket
func (s *Service) sendSocket(message string) string {
	stopCharacter := "\r\n\r\n"
	addr := strings.Join([]string{s.OpenVASIP, s.OpenVASPort}, ":")
	conn, err := tls.Dial("tcp", addr, &tls.Config{InsecureSkipVerify: true})

	defer conn.Close()

	if err != nil {
		log.Info("Service: Pentest:", err)
	}

	conn.Write([]byte(message))
	conn.Write([]byte(stopCharacter))

	buff := make([]byte, 1024)
	n := 1024
	var line string
	for n > 0 && n == 1024 {
		n, _ = conn.Read(buff)
		line = line + fmt.Sprintf("%s", buff[:n])
	}

	return line
}

// a wrapper fo printValue to use strings and not string pointers
func printValueStr(message string, length int) string {
	return printValue(&message, length)
}

// this function will add spaces to a string, until the length of the string is like we need it
// thats useful to make the output more pretty
func printValue(message *string, length int) string {
	if message != nil {
		if len(*message) < length {
			*message = *message + " "
			return printValue(message, length)
		}
	} else {
		newMsg := " "
		return printValue(&newMsg, length)
	}
	return *message
}

func markdownRender(content string) string {
	htmlFlags := 0
	htmlFlags |= blackfriday.HTML_USE_SMARTYPANTS
	htmlFlags |= blackfriday.HTML_SMARTYPANTS_FRACTIONS

	renderer := blackfriday.HtmlRenderer(htmlFlags, "", "")

	extensions := 0
	extensions |= blackfriday.EXTENSION_NO_INTRA_EMPHASIS
	extensions |= blackfriday.EXTENSION_TABLES
	extensions |= blackfriday.EXTENSION_FENCED_CODE
	extensions |= blackfriday.EXTENSION_AUTOLINK
	extensions |= blackfriday.EXTENSION_STRIKETHROUGH
	extensions |= blackfriday.EXTENSION_SPACE_HEADERS

	return string(blackfriday.Markdown([]byte(content), renderer, extensions))
}
